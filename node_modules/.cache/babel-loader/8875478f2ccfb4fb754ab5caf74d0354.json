{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validators = exports.isNameAllowed = exports.isMinSuperiorThanMax = exports.getUsedContentTypeAttributeNames = exports.createTextShape = exports.alreadyUsedAttributeNames = exports.NAME_REGEX = void 0;\n\nvar yup = _interopRequireWildcard(require(\"yup\"));\n\nvar _lodash = require(\"lodash\");\n\nvar _strapiHelperPlugin = require(\"strapi-helper-plugin\");\n\nvar _getTrad = _interopRequireDefault(require(\"../../../../utils/getTrad\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nvar NAME_REGEX = new RegExp('^[A-Za-z][_0-9A-Za-z]*$');\nexports.NAME_REGEX = NAME_REGEX;\n\nvar alreadyUsedAttributeNames = function alreadyUsedAttributeNames(usedNames) {\n  return {\n    name: 'attributeNameAlreadyUsed',\n    message: _strapiHelperPlugin.translatedErrors.unique,\n    test: function test(value) {\n      if (!value) {\n        return false;\n      }\n\n      return !usedNames.includes(value);\n    }\n  };\n};\n\nexports.alreadyUsedAttributeNames = alreadyUsedAttributeNames;\n\nvar getUsedContentTypeAttributeNames = function getUsedContentTypeAttributeNames(ctShema, isEdition, attributeNameToEdit) {\n  var attributes = (0, _lodash.get)(ctShema, ['schema', 'attributes'], {});\n  return Object.keys(attributes).filter(function (attr) {\n    if (isEdition) {\n      return attr !== attributeNameToEdit;\n    }\n\n    return true;\n  });\n};\n\nexports.getUsedContentTypeAttributeNames = getUsedContentTypeAttributeNames;\n\nvar isNameAllowed = function isNameAllowed(reservedNames) {\n  return {\n    name: 'forbiddenAttributeName',\n    message: (0, _getTrad[\"default\"])('error.attributeName.reserved-name'),\n    test: function test(value) {\n      if (!value) {\n        return false;\n      }\n\n      return !reservedNames.includes(value);\n    }\n  };\n};\n\nexports.isNameAllowed = isNameAllowed;\nvar validators = {\n  \"default\": function _default() {\n    return yup.string().nullable();\n  },\n  max: function max() {\n    return yup.number().integer().nullable();\n  },\n  min: function min() {\n    return yup.number().integer().when('max', function (max, schema) {\n      if (max) {\n        return schema.max(max, (0, _getTrad[\"default\"])('error.validation.minSupMax'));\n      }\n\n      return schema;\n    }).nullable();\n  },\n  maxLength: function maxLength() {\n    return yup.number().integer().nullable();\n  },\n  minLength: function minLength() {\n    return yup.number().integer().when('maxLength', function (maxLength, schema) {\n      if (maxLength) {\n        return schema.max(maxLength, (0, _getTrad[\"default\"])('error.validation.minSupMax'));\n      }\n\n      return schema;\n    }).nullable();\n  },\n  name: function name(usedNames, reservedNames) {\n    return yup.string().test(alreadyUsedAttributeNames(usedNames)).test(isNameAllowed(reservedNames)).matches(NAME_REGEX, _strapiHelperPlugin.translatedErrors.regex).required(_strapiHelperPlugin.translatedErrors.required);\n  },\n  required: function required() {\n    return yup[\"boolean\"]();\n  },\n  type: function type() {\n    return yup.string().required(_strapiHelperPlugin.translatedErrors.required);\n  },\n  unique: function unique() {\n    return yup[\"boolean\"]().nullable();\n  }\n};\nexports.validators = validators;\n\nvar createTextShape = function createTextShape(usedAttributeNames, reservedNames) {\n  var shape = {\n    name: validators.name(usedAttributeNames, reservedNames),\n    type: validators.type(),\n    \"default\": validators[\"default\"](),\n    unique: validators.unique(),\n    required: validators.required(),\n    maxLength: validators.maxLength(),\n    minLength: validators.minLength(),\n    regex: yup.string().test({\n      name: 'isValidRegExpPattern',\n      message: (0, _getTrad[\"default\"])('error.validation.regex'),\n      test: function test(value) {\n        return new RegExp(value) !== null;\n      }\n    }).nullable()\n  };\n  return shape;\n};\n\nexports.createTextShape = createTextShape;\nvar isMinSuperiorThanMax = {\n  name: 'isMinSuperiorThanMax',\n  message: (0, _getTrad[\"default\"])('error.validation.minSupMax'),\n  test: function test(min) {\n    if (!min) {\n      return true;\n    }\n\n    var max = this.parent.max;\n\n    if (!max) {\n      return true;\n    }\n\n    if (Number.isNaN((0, _lodash.toNumber)(min))) {\n      return true;\n    }\n\n    return (0, _lodash.toNumber)(max) >= (0, _lodash.toNumber)(min);\n  }\n};\nexports.isMinSuperiorThanMax = isMinSuperiorThanMax;","map":{"version":3,"sources":["/home/zenack/Trabajo/Strapi-concept/.cache/plugins/strapi-plugin-content-type-builder/admin/src/containers/FormModal/attributes/validation/common.js"],"names":["NAME_REGEX","RegExp","alreadyUsedAttributeNames","usedNames","name","message","errorsTrads","unique","test","value","includes","getUsedContentTypeAttributeNames","ctShema","isEdition","attributeNameToEdit","attributes","Object","keys","filter","attr","isNameAllowed","reservedNames","validators","yup","string","nullable","max","number","integer","min","when","schema","maxLength","minLength","matches","regex","required","type","createTextShape","usedAttributeNames","shape","isMinSuperiorThanMax","parent","Number","isNaN"],"mappings":"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","sourcesContent":["import * as yup from 'yup';\nimport { get, toNumber } from 'lodash';\nimport { translatedErrors as errorsTrads } from 'strapi-helper-plugin';\nimport getTrad from '../../../../utils/getTrad';\n\nconst NAME_REGEX = new RegExp('^[A-Za-z][_0-9A-Za-z]*$');\n\nconst alreadyUsedAttributeNames = usedNames => {\n  return {\n    name: 'attributeNameAlreadyUsed',\n    message: errorsTrads.unique,\n    test: value => {\n      if (!value) {\n        return false;\n      }\n\n      return !usedNames.includes(value);\n    },\n  };\n};\n\nconst getUsedContentTypeAttributeNames = (ctShema, isEdition, attributeNameToEdit) => {\n  const attributes = get(ctShema, ['schema', 'attributes'], {});\n\n  return Object.keys(attributes).filter(attr => {\n    if (isEdition) {\n      return attr !== attributeNameToEdit;\n    }\n\n    return true;\n  });\n};\n\nconst isNameAllowed = reservedNames => {\n  return {\n    name: 'forbiddenAttributeName',\n    message: getTrad('error.attributeName.reserved-name'),\n    test: value => {\n      if (!value) {\n        return false;\n      }\n\n      return !reservedNames.includes(value);\n    },\n  };\n};\n\nconst validators = {\n  default: () => yup.string().nullable(),\n  max: () =>\n    yup\n      .number()\n      .integer()\n      .nullable(),\n  min: () =>\n    yup\n      .number()\n      .integer()\n      .when('max', (max, schema) => {\n        if (max) {\n          return schema.max(max, getTrad('error.validation.minSupMax'));\n        }\n\n        return schema;\n      })\n      .nullable(),\n  maxLength: () =>\n    yup\n      .number()\n      .integer()\n      .nullable(),\n  minLength: () =>\n    yup\n      .number()\n      .integer()\n      .when('maxLength', (maxLength, schema) => {\n        if (maxLength) {\n          return schema.max(maxLength, getTrad('error.validation.minSupMax'));\n        }\n\n        return schema;\n      })\n      .nullable(),\n  name: (usedNames, reservedNames) => {\n    return yup\n      .string()\n      .test(alreadyUsedAttributeNames(usedNames))\n      .test(isNameAllowed(reservedNames))\n      .matches(NAME_REGEX, errorsTrads.regex)\n      .required(errorsTrads.required);\n  },\n  required: () => yup.boolean(),\n  type: () => yup.string().required(errorsTrads.required),\n  unique: () => yup.boolean().nullable(),\n};\n\nconst createTextShape = (usedAttributeNames, reservedNames) => {\n  const shape = {\n    name: validators.name(usedAttributeNames, reservedNames),\n    type: validators.type(),\n    default: validators.default(),\n    unique: validators.unique(),\n    required: validators.required(),\n    maxLength: validators.maxLength(),\n    minLength: validators.minLength(),\n    regex: yup\n      .string()\n      .test({\n        name: 'isValidRegExpPattern',\n        message: getTrad('error.validation.regex'),\n        test: value => {\n          return new RegExp(value) !== null;\n        },\n      })\n      .nullable(),\n  };\n\n  return shape;\n};\n\nconst isMinSuperiorThanMax = {\n  name: 'isMinSuperiorThanMax',\n  message: getTrad('error.validation.minSupMax'),\n  test(min) {\n    if (!min) {\n      return true;\n    }\n\n    const { max } = this.parent;\n\n    if (!max) {\n      return true;\n    }\n\n    if (Number.isNaN(toNumber(min))) {\n      return true;\n    }\n\n    return toNumber(max) >= toNumber(min);\n  },\n};\n\nexport {\n  alreadyUsedAttributeNames,\n  createTextShape,\n  getUsedContentTypeAttributeNames,\n  isMinSuperiorThanMax,\n  isNameAllowed,\n  validators,\n  NAME_REGEX,\n};\n"]},"metadata":{},"sourceType":"script"}